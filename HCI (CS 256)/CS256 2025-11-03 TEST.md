


# Exam Details

- Tues. Nov 4 - Mon. Nov 10.
- Can be taken at any point. BUT must be taken in **one sitting**. (Can't be saved and opened later)
- 2 HOUR TIME LIMIT (should take you ~60-90 mins).

- 26 total questions.
    - Multiple choice, matching, multiple select, fill in the blank.
    - Short answer.
    - 2 long answer.
        - Camea warns these will take a decent amount of time. She recommends skipping to them and doing them first.

- Open-book, open note.
- Closed internet, closed AI, closed person.
- Non-proctored.

# Content review

## Norman's Principles of Interaction

- Signifiers.
    - Physical sign or indicator to let the user know an action is available.
- Affordances.
- Constraints.
    - Limiting user's possible actions to guide them towards performing the correct ones.
    - Something that stops the user from completing an "incorrect" action or an action in an incorrect way.
    - Types of constraints:
        - Physical constraint:
            - e.g. you physically can't put a USB in the wrong way.
        - Cultural constraint:
            - Only understandable by one (or a few) culture(s). People from outside that/those culture(s) won't understand that constraint, which presents a barrier for them.
            - e.g. traffic signs in the US are in English and have different icons and visual language compared to other countries.
        - Logical constraint:
            - Makes a function only performable in one certain way.
            - e.g. a jigsaw puzzle: can only be put together in one certain way.
        - Semantic constraint:
            - Depends on user's past experience.
            - e.g. a greyed-out button on a webpage. 
- Mapping.
    - Communicating interface's function.
- Feedback.
    - Response to user.
    - Anything that tells you an action was completed, and/or the new state of the system after completing the action.

Know these and use them in your responses. Show you know what they are and how to use them.

- Signifier vs. affordance:
    - Signifier: Shows you what you can do.
    - Affordance: What's physically possible to do. 
        - Not obvious.
        - How you can interact w/ it is implied.

## Iterative Design Cycle

4 stages:

1. Observe
2. Ideate
3. Prototype
4. Test
5. (return to 4.)

Digging deeper:

- Observation
    - Recognizing a problem or a user's need. 
- Ideation
    - Brainstorming ideas for solutions.
    - Quantity over quality.
    - No idea is not considered&mdash;doesn't matter how crazy.
- Prototyping
    - Making a mock-up of your design.
    - Types of prototyping:
        - Low fidelity
        - High fidelity
- Testing
    - Evaluating how effective your design was.

What makes this a cycle?

Kamea says: "Please, I beg you, **use the word 'iteration' in your answer**. Design never stops."

During iteration, you don't necessarily have to follow the cycle each stage forward at a time. 

## Norman's Action Cycle

3 steps describing an individual's interaction with things in the world:

1. Goal formation
2. Execution
3. Evaluation

Digging deeper:

- Goal formation
    - Similar to Ideation.
- Execution
    - Achieving the goal.
- Evaluation
    - Similar to Testing.

### Execution vs. Evaluation

- Gulf of Execution:
    - The bridge between the user's goal and what the available actions are.
    - What actions are possible? How to perform those actions? What will the product's response be?
    - For us designers, the gulf of execution is when we need to consider stuff like signifiers, etc.
- Gulf of Evaluation:
    - The bridge between the user's perception of system state and whether or not their goal was fulfilled.
    - The world has changed as a result of the user's execution. How do they know what they've done is right?
    - What was the system's response? Does it match the user's intention?
    - Concepts like System Image come into play here.

## Knowledge in head vs. world

- Recall: Knowledge in the head.
    - The knowledge that the user always has in their head. 
    - Requires users to remember and recall information. This takes a LOT of mental effort to remember&mdash;especially if it's more complicated.
- Recognition: Knowledge in the world.
    - The knowledge the user has available outside of their own head.
    - Requires the user to deduce how to solve a problem without relying on memory only.
    - Constraints play a big role guiding the user through your system. (e.g. the layout of a keyboard or where a button is placed)


Recall: memorizing music. Recognition: reading sheet music.

*Which is better? Recognition or recall?* Recognition is better, because it reduces cognitive load. (At least in UX design, anyway.)

## User Perception

Users perceive designs using past experience and familiar context.

(All you have to play with is the user's past knowledge...which is hard, bc everyone has different past knowledge.)

How to visually reduce cognitive load:

- Clear headings
- Short blocks of text
- Bullet points
    - Aside: Kamea asked 
- Clear fonts
- Limited capitalization and emphasized text
- High contrast btwn background color and text color
- Limited use of complementary colors
    - Complementary colors compete for attention. Using a lot at once ruins visual hierarchy.


## Heuristic Analysis

Dr. Hughs's slide deck on Canvas is v great, Kamea says. She highly suggests looking over them.

1. Visibility of system status.
2. Match btwn system and the real world.
3. User control and freedom.
4. Consistency and standards.
5. Error prevention.
6. Recognition rather than recall.
7. Flexibility and efficiency of use.
8. Aesthetic and minimal design.
9. Help users recognize, diagnose, and recover from errors.
10. Help and documentation.

A lot of the steps bleed into each other. So if a question asks you which step something is, don't worry as much about picking the specific correct step; focus on demonstrating you understand the steps and the process.

## Eyes: Macula vs. Peripery

- Macula
    - More conse
    - Better for close reading/study
    - Slower
    - Color
- Periphary
    - Gray and blurry
    - Really fast; takes in a lot of info
    - Detects objs to one side out of main view
    - Sees group of objects

## Gestalt Principles

Kamea says she'll be very happy if you use these in your responses.

- Proximity
    - Objects close to each other appear grouped together.
- Similarity
    - Objects that look similar appear grouped together.
- Continuity
    - Objects in a *segmented* pattern form appear grouped together making a continuous form.
    - "Segmented" is the key word there that makes Continuity different from Closure.
- Closure
    - Our perception fills in *open figures* to form a complete object instead of fragments.
    - Closure is about interpreting the white space.
- Symmetry
    - Our vision automatically simplifies an object and acknwoledges its symmetry.

Why do we need to use Gestalt Principles? - Communicating how things are grouped together. These principles describe how our brain perceives visual information.

## Interviews/Contextual Inquiry

Difference: 

- Contextual inquiry: in context.
    - You're watching the user interact with the design, often within the same setting where they often use it. 
- Interview: out of context.
    - You're asking the user questions.

Interviewing:

- Asking questions
    - Focus on one subject at a time.
    - Open the door to a meaningful response.
        - Give yourself the data you need. 
            - (You're writing the questions! If you need to know about a certain element, ask about that element.)
        - Avoid yes/no questions.
            - Yes/no questions rarely provide useful data.
        - Avoid leading questions.
    - Ask with purpose.
    - Make eye contact.
    - Keep language simple/common.
        - Don't use UX jargon.
- Master/Apprentice model: Treat your interviewee as the master, with yourself the apprentice. Treat them like they're the expert.
    - Observe and learn.
    - Ask them questions!
    - Imagine their presepctiev.
    - Treat them like an expert.

## Usability Study

Obseration of how users interact w/ your product.

1. What problem are you solving? How will the study help you?
    - Clearly define what info you want to get out of your study?
        -  What do you want to know?
2. Who are your target users?
    - What are their needs, demographics, problems, etc.
3. What tasks will the user be performing?
    - Create a scenario.
    - Detail the instructions that will guide your user through these tasks.
4. How will you test your users?
    - Observation in real-time vs. moderated?
    - Remote vs. in-person?
    - W/ a prototype vs. real product?
5. Gather and interpret data.
    - Will you need continuous data, or discrete data?

^ This is what we've been doing in the class as we've been working on our group project.


## Laws of UX

Old slide. You don't need this.

## Prototyping

- Lo-Fidelity
    - Typically a paper sketch. 
    - Pros:
        - Easily changeable, quick iteration.
        - Cheap.
    - Cons:
        - Very simplified.
        - Can't be interacted with, so testing is clunkier.
- Hi-Fidelity
    - Pros:
        - Very complete.
        - Arguably collaboration is easier. (Working in a Figma doc vs. huddled around a piece of paper.)
        - Transitions into real product.
    - Cons:
        - Expensive.
        - Implementing changes is a lot more time-intensive.
        - Can cause a client to think the product's a lot further along in the design process than it actually is.