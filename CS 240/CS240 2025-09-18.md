2025 09 18  
CS 240  
Ken Rodham  

# Object.clone

`Object.clone` returns a new object with the same values as the object it's called on.

## Overriding

By default, `clone` is **protected**. You'll likely want to make it public. 

`Object.clone`'s return type is `Object`, but you'll probably want to change its return type to be the class you're returning. 

> When overriding superclass methods, the method name & parameters must be the same, but the return type & access modifier can be different.

# Interfaces

Interfaces are a level of abstraction. (And polymorphism, I think.)

Gemini describes an interface as a **blueprint for a class/classes.** 

- In an interface, you define static constants & methods, and abstract methods.
    - Abstract = no body, i.e. undefined. **You're not defining how subclasses operate, only how other classes can interact with them.**
- By default, all methods are public and abstract.
- A class can inherit from multiple interfaces.

## Syntax

Use the keyword `implements` in a class signature 

```java
public interface Moveable {
    void go();
}

public class Dog extends Animal implements Moveable, Runnable, Edible {

    @Override
    public void go() {
        // start moving all four legs forward.
    }
}
```


# Abstract classes

So, you made an interface, and a bunch of subclasses inherit from it. But a lot of your subclasses have the same behavior, so you have tons of code duplication. But you can't define the common behavior in the interface, so wtf do you do??

The solution is to use an **abstract class**. Abstract classes are like an in-between btwn interfaces & concrete classes.


- Interfaces: Purely abstract.
- Abstract classes: Partially implemented.
- Concrete classes: Fully implemented.


# Records

In Java, you have a lot of boiler plate code for fields; getters/setters; toString, equals, and hashCode; etc.

So the gods of Java 

## Example

```java
public class Pet {
    private int id;
    private String name;
    private String type;

    public Pet(int id, String name, String type) {
        this.id = id;
        this.name = name;
        this.type = type;
    }

    public int getID() { 
        return id;
    }
    
    public String getName() { 
        return name; 
    }
    
    public String getType() { 
        return type; 
    }

    public void setID(int newID) {
        id = newID;
    }

    public void setName(String newName) {
        name = newName;
    }

    public void setType(String newType) {
        type = newType;
    }

    @Override 
    public String toString() {
        return "Pet{id=" + id + 
                ", name=" + name + 
                ", type=" + type + "}";
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id, name, type);
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }

        Pet that = (Pet) o;
        return id == that.id && name.equals(that.name) && type.equals(that.type);
    }

    // NOW we can get started with defining the pet...
}
```


That is SO MUCH BOILER PLATE CODE!! 



```java
public record Pet(int id, String name, String type) {
    // look! Now we're already ready to start defining the pet!
}
```

## Uses

Records are great for data classes that don't have a lot of other methods in them. (Think of the Node struct we used all the time in CS 235.)

## Features & limitations

- Record objects are **immutable**.
    - **All fields are final.**
- Automatic getters.
    - Instead of `pet.getName()`, it's `get.name()`.
- Automatic equals, hashCode, and toString.
    - You can override them, if you'd like.

# Nested classes

Nested classes are classes that exist within other classes. They're useful when you have a class that only one class uses. (Think of the Node struct we used all the time in CS 235.)

## Classes nested in classes

To define an inner class, just define a class inside another class.

An inner class has access to all the outer class's methods and fields and stuff (so long as the inner class is not static.)

### Classes nested in methods

Inner classes can be nested inside methods. (But then it only exists in that method's scope.) When an inner class exists inside a method, it has access to the parameters and local variables in that method's scope.

#### Classes nested in methods declared at the end

Here's where it gets crazy: If you've defined an inner class inside a method that returns an object of that class, you can actually just fully declare that class inside the `return new ____` line. When you do this, you don't even have to name the inner class (**"anonymity"**).


e.g. instead of--

```java
public class DataStructure {
    ...
    public Iterator iterator(final int increment) {
        private class Iterator {
            ...
        }
        return new Iterator();
    }
}
```

--you can do--

```java
public class DataStructure {
    ...
    public Iterator iterator(final int increment) {
        return new class Iterator() {

        };
    }
}
```

--or something 

Ken Rodham said these are actually really useful, and often used in **event handlers**. There might be dozens of events that occur, and you'd need to write a class that handles each one. In the future, we'll actually have to make a bunch of event handlers, so keep this knowledge in your back pocket til then.