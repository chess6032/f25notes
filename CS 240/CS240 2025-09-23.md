2025 09 23  
CS 240  
Ken Rodham  

# EXAM TODAY

Scary.

If Honorlock breaks on you, Rodham says to just keep going and they'll trust you didn't treat.

(Remember, they want you to pass.)

# Start of Phase 1

In Phase 1, you implement ChessGame. And that's about it.

ChessGame includes methods that primarily care about check & checkmate. In other words, its job is to take the moves that ChessPiece.pieceMoves proposes, and filter out the ones that would be invalid for putting the king in check and checkmate and stuff.

You also need to implement the functionality of actually performing a move.


# Data Structures in Java

Data structure types in Java:

- Array (`[]`)
- Collection
    - List
    - Set
    - Queue
- Map
- Iterator

## Collections

- When to use: When regular arrays (`[]`) don't suffice.
- `import java.util.Collection`
- Collection is an **interface**: it includes common methods across all "list"-esc data types.
    - e.g. insert, remove, etc.
- **Can only store objects, not primitives.**
    - The reason for that is that these collections weren't added until a later version of Java.
    - If you really want to contain primitives in Collections, you can **use the primitive's wrapper classes**.
        - Seems clunky...until you realize that Java actually does "autoboxing" (or smth, I didn't quite catch what it was called) so that syntactically it looks the same. 
- Almost all data types that hold a collection of objects inherit from Collection...EXCEPT for Maps.

## Algorithms

Common algorithms we perform on data structure:

- Sorting. 
    - Java has built in sort functions. 
        - For the Collection interface, you can find sorting functions in the Collections class. (lmao isn't that stupid.)
        - An Arrays class also exists for arrays. 
        - An Objects class also exists...for all objects.
            - e.g. Objects.compare, which is important for sets, where objects must be compared when placed in (bc it's a BST).
- Shuffle.
- etc.


Whenever you want to use a common algorithm, your first instinct should be to find a common library that has already implemented this.

## Collection subclasses

### List

- Ordered sequence of elements accessed by index.
- Interface. Two implementations:
    - ArrayList: Uses an array that is adjusted in size as needed.
    - LinkedList: Doubly-linked list.
    - (Recall your knowledge from CS 235 to determine which data structure works best for your situation.)
        - But also in addition to that knowledge, Ken alluded that array lists work well with computers' caching behavior...to the point that some argue that linked lists should never be used. 
- Important methods: `get(idx)` and `set(idx)`.
- Supports a more powerful iterator type: `ListIterator`

### Set

- Interface.
    - HashSet. (hash table implementation.)
    - TreeSet. (balanced BST implementation.)
    - How to decide btwn HashSet & TreeSet: HashSets are faster, but TreeSets take less space and are sorted.
    - LinkedHashSet. (hash table + linked list!)
        - In addition to a hash table, it has a linked list that is added to each time smth is added to the hash table. This way, when you iterate across the table, you iterate across it in the order that you added to it...so that's cool, ig.
- An unordered (usually) collection that contains no duplicates.
- Iportant methods: `add(value)`, `contains(value)`, `remove(value)`.

### Queue

- Interface.
    - ArrayDeque. (FIFO. Resizable array implementation.)
        - "Deque" = double ended queue. You can insert and remove at BOTH ends of the queue, efficiently.
            - Means you could actually treat it as LIFO, if you wanted. (You freak.)
    - LinkedList. (FIFO. LL implementation.)
    - PriorityQueue. (Priority queue. Binary heap implementation.)
        - For priority queues, the Objects it contains must some sort of way of comparrison implemented.
- Designed for holding elements prior to processing.
- Important methods: `add(value)`, `peek()`, `remove()`.


### Deque

- Interface.
    - ArrayDeque
    - LinkedList
- Suppports efficient insertion and removal at both ends.

### Stack

- Java's Stack class is eprecated.
- If you need a stack, use a Deque.
    - push: `Deque.addFirst`
    - pop: `Deque.removeFirst`
    - peek: `Deque.peekFirst`

## Maps

- Maps keys to values.
- Important methods: 
    - `put(key, value)`
    - `get(key)`
    - `contains(key)`
    - `remove(key)`
    - `keySet()` (returns a set of the map's keys.)
    - `values()` (returns a collection the map's values.)
    - `entrySet()` (returns a set of key-value pairs. coolest way to iterate over the map.)
        - Data type: Set of entries.
- Interface
    - HashMap (hash table implementation)
    - TreeMap (BST implementation)
    - LinkedHashMap (preserves insertion order)

## Iterable Interface

- All collections (but not maps) implement the Iterable interface.
- Implementing the Iterable interface allows you to use Java's foreach loop on the data structure.


# Collections in Java

## Equality & Hashing

- Equaility
    - Compare all elements in each collection.
- Hashing
    - If you're using a hashing-based collection, the class it contains MUST have `Object.hashCode` implemented.
- RULE: 
    - If equals is based on identity, so should the `hashCode` be. If equals is based on value, so should `hashCode`. 
    - `equals` and `hashCode` should use the same fields in their calculations.

## Objects as keys in maps

Consider: You have an object that serves as a key in a map. What would happen if somehow you modify that object? All the sudden, that object's in the wrong position in the tree or hashtable.

**Never change information in objects that are used as keys in data structures.** If you need to, you must **remove it, change it, then re-insert it**.

Ken says this is a cautionary tale. He says, "I personally have never done that...in a while."


## Sorted Collections

- Sorted collections: 
- Java interface: Comparable.
    - If you want your class to be comparable, implement the built-in `Comparable` interface and override its `compareTo` method.

### Example: TimeOfDay


```java

public class TimeOfDay implements Comparable<TimeOfDay> {

    private int hour;
    private int minute;

    ...

    @Override
    public int compareTo(TimeOfDay timeOfDay) {
        int result = Integer.compare(hour, timeOfDay.hour); // compare hours
        if (result == 0) { // hours are equal
            result = Integer.compare(minute, timeOfDay.minute); // compare minutes
        }
        return result;
    }

};
```

# Exceptions & Exception Handling

Java is a little bit different from other languages in the sense that it *forces* you to handle exceptions. 

## Exceptions overview

- Abnormal conditions that can occur in a Java class.
- May be but are not necessarily errors.
- Allow you to separate normal processing logic from abnormal processing logic.
- Represented by classes and objects in Java.

Sometimes, that are errors that occur due to things out of your control (e.g. wonky user input, internet's down, file IO doesn't work bc file's corrupted).


## You're forced to handle exceptions

When defining a function, you can say that it throws an exception. When you do this, any time that function is called, it has to be surrounded in a try/catch block. (Not doing so will cause a compiler error.)

### Example

Java's Scanner class constructor throws a `FileNotFoundException`. As such, whenever you instantiate a Scanner, you HAVE to put a try/catch block around it.

```java
public Scanner scannerFactory(File file) {
    try {
        Scanner scanner = new Scanner(file);
    } catch (FileNotFoundException ex) {
        System.out.println("Could not find file: " + file);
        ex.printStackTrace();
    } catch (IOException ex) {
        System.out.println("I/O error occured: " + file);
        ex.printStackTrace();
    } catch (Exception ex) {
        System.out.println("Non-I/O error occured: " + file);
        ex.printStackTrace();
    }

    return scanner;
}
```

## Letting exceptions propagate up

If you don't catch an exception, then it moves up the runtime stack. If it gets to the main function and main doesn't catch it, then the program crashes.

That's actually oft appropriate to not immediately handle an exception, b/c maybe the things you need to handle that exception aren't in scope within where the exception originates. (Holy f*ck that makes no sense lmaaaooooo good luck.)

**To allow exceptions to propagate up the stack, you should include that the function will throw a certain exception.**

Using the Scanner variable from earlier:

```java
public Scanner scannerFactory(File file) throws FileNotFoundException {
    // don't need try-catch block because "throws FileNotFoundException"
    // delegates handling the exception to whoever calls this function.
    Scanner scanner = new Scanner(file);
    return scanner;
}
```

## Inheritance hierarchy

- Object
    - Throwable
        - Error (unchecked)
            - (you're cooked)
            - OutOfMemoryError
            - StackOverflowError
        - Exception (checked)
            - RuntimeException (unchecked)
                - (you're cooked)
                - NullPointerException
                - IndexOutOfBoundsException
            - Other exceptions (checked)
                - IOException
                - ClassNotFoundException
                - FileNotFoundException

Java does not force you to handle exceptions inherited from "Error" and "RuntimeException", bc they imply that your program has a bug that made it break completely. The solution for those exceptions is not to catch them, it's to fix your code.

## Try/catch flow

In a try/catch block, any code placed after where an exception occurs will not b

In a try/catch block, make sure that any resources you allocate get properly de-allocated, no matter what exception is thrown.

# Misc

## File I/O

Java has a File class that is really just a wrapper for a string that is a file path.

Java has a Scanner class that scans tokens in a file. Always call `Scanner.close` when you're finished using the file.