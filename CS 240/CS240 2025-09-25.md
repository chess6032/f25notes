2025 09 25  
CS 240  
Ken Rodham  
Generics, Lambdas, and I/O

Today is our last day focusing on learning Java.

# Exceptions: Print Stack Trace

We saw this in the code last time, but Ken forgot to explain it.

Everything that inherits from the Exception class has a `printStackTrace` function that prints the "stack trace" that lead to the exception being thrown. 

## Aside: Never have an empty catch block

Never catch an exception and then leave that block empty.


# Generics

If you've ever inputted a class into angled brackets (`<>`), then you've used generics.

## Writing a generic class

Example:

```java
public class Pair<T, U> {
    private T value1;
    private U value2;

    public Pair(T value1, U value2) {
        this.value1 = value1;
        this.value2 = value2;
    }
}
```

You write your code normally, but you use those generics (`U` and `T`) where you would otherwise put a specific type.

## Instantiating a generic class

Old way w/ redundant type declaration: `Pair<String, Integer> pair1 = new Pair<String, Integer>("Hello", 123);`

New way: `Pair<String, Integer> pair2 = new Pair<>("Hello", 123);`

Even better, newer way: `var pair3 = new Pair<String, Integer>("Hello", 123);` (`var` in Java is what `auto` is in C++. Basically, the compiler looks at what the variable is being assigned to, and makes that the variable's type.)

## Using generic classes

### Inheriting from a generic class

You can make a subclass of the generic class that always uses a specific type:

```Java
public class StringPair extends Pair<String, String> {
    public StringPair(String value1, String value2) {
        super(value1, value2);
    }
}
```

Or, you can make a subclass that specifies one of the superclass's generic types, and leaves others generic:

```Java
public class KeyValuePair<V> extends Pair<String, V> {
    public KeyValuePair(String value1, V value2) {
        super(value1, value2);
    }
}
```

## Generic Interfaces

```java
public interface Function<T, R> {
    R apply(T param);
}

public class Capitalizer implements Function<String, String> {
    @Override
    public String apply(String param) {
        return param == null ? null : param.toUpperCase;
    }
}

public class StringManipulator {
    public String manipulateString(String str, Function<String, String> manipulationFunction) {
        return manipulationFunction.apply(str);
    }
}

// uhhh I missed what he did with all of this in Main
```

## Wildcards

Wildcards w/ special syntax can be used to expand the acceptable types.

- Simplest wildcard: `?`
    - e.g. `public void method1(List<?> param)`
- But you can also restrict it:
    - e.g. `public void method2(List<? super T> param)` accepts anything that is `T` or is a *superclass* of `T`.
    - e.g. `public void method3(List<? extends T> param)` accepts anything that is `T` or is a *subclass* of `T`. 

# Lambdas

## Functional Interfaces

Rodham noted a few interfaces that he wants us to be aware of:

- Java has a Runnable interface. All it has is a function `run`, which returns void.
- Java has a Callable interface, which is generic. All it has is a function called `call`, which returns the generic. (The difference btwn Runnable and Callable is that )
- Java has a Comparable interface, which only has one, `compare`. Java uses this method e.g. when sorting.

All these interfaces only have one method. Interfaces with only one method are called **functional interfaces**. Rodham says they exist because of lambdas.

## Wtf is a lambda????????

In Java, functions are not first-class members. ("First class" means that it can be assigned to a variable, or used as a type for a function's parameter.)

Lambdas are an efficient way to use functions as first-class members. 

## Sorting example

By default, Java sorts strings alphabetically. But what if we want to write our own sorter that sorts the strings based on length?

### Method 1: Define a comparator elsewhere.

```java
String[] values = { ... }

Arrays.sort(values, new StringLengthComparator()); // StringLengthComparator returns a class (defined elsewhere) that implements Java's Comparator interface.

... 

public class StringLengthComparator() implements Comparator<String> {
    @Override
    public int compare(String first, String second) {
        return first.length() - second.length(); 
    }
}
```

### Method 2: with anonymous inner class

```java
Arrays.sort(values, new Comparator<String>() { // here we define a class inside the function header
    @Override 
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}); 
```

### Method 3: with lambda expression

```java
Arrays.sort(values, (String first, String second) -> { return first.length() - second.length(); })
```

But wait! `Arrays.sort` expects its second parameter to be an object that implements `Comparator`, and calls the `compare` class on it. So how is this able to work?!?

It's because `Comparator` is a **functional interface**. The Java compiler takes your lambda, sees the parameter type for `Arrays.sort` is a `Comparator`, and does this: It generates a new class that implements `Comparator`, then sticks your lambda function in for the `compare` function.

**Generalizing that: When you pass in a lambda to a parameter that expects an object that implements a functional interface, Java creates a class that implements that functional interface and overrides that interface's sole function with your lambda.**

### Method 4: Concise lambda

```java
Arrays.sort(values, (first, second) -> first.length() - second.length());`
```
Notice the changes: 

- We dropped the types for the parameters.
    - Java looks at how you use the parameters, and assumes what type they should be.
- We dropped the `return` statement.
    - If you write a lambda with only one single statment, Java makes that its return.

## So where can you use lambdas?

**You can only use lambdas for variables or  parameters whose type implements a functional interface.**

## Using lambdas

We've seen how you can use lambdas as parameters. How else can you use lambdas?

### Storing lambdas in variables

You can store lambdas in variables (so long as the variable type implements a function interface).

### Creating APIs w/ Lambdas

You can create functions that are explicitly designed to accpet a function as an input and then use that functin in its code.

(These types of functions are called "higher order functions".)

### Generic interfaces and lambdas

Rodham disclaimed that in a previous example, he demonstrating writing your own `Function` class...but that's already defined in Java.

Also in that example, we created our own class that implemented the Function interface. But now that we now about lambdas, we can shorten our code!

```java
import java.util.functions.Function;

public class StringManipulator {
    public String manipulateString(String str, Function<Sring, String> manipulationFunction) {
        return manipulationFunction.apply(str);
    }
}

public static void main(String[] args) {
    var sm = new StringManipulator();
    String s  as;ldfh poaisiu fopashdof s
}

//  I MISSED THE ACTUAL LAMBDA DANGIT
```

### Method References

It's very often that you have lambdas that just call a function on another class, e.g.:

```java
intList.forEach(x -> System.out.println(x));
```

But Java lets us condense that even more:

```java
intList.forEach(System.out::println);
```

That line generates a lambda, that in turn does all the lambda stuffs.

`System.out::println` is called a **method reference**. Rodham says this is the most concise lambdas. He says this syntax exists because these kinds of lambdas are so common.

Method refs can be used for static, instance, and constructor invocations. The syntax varies a little bit between those. (See the slides.)

## Why care about lambdas?

In Phase 3, when we write our server, Rodham says we'll probably want to use lambda functions.

Admitedly, Java is not the cleanest language for using lambda features. But we do what we can with what we have.


# Input/Output (Streams & Files)

Ways to read/write:

- Streams
    - Read/write a file (or other source/dest of bytes) **sequentially**.
- `Scanner` class.
    - **Tokenize stream input.**
    - Has `hasNext` and `next` methods, just like the Iterator interface.
    - Has other next functions for grabbing specific tokens:
        - `nextInt`, `nextFloat`
        - `nextLine`, if you want to read line-by-line.
- `Files` class.
    - Has methods for performing operations on entire files.
        - e.g. copy, move, create directory, etc. 
    - (Not to be confused with the `File` class, which is just a filepath wrapped inside an object.)
- `RandomAccessFile` class.
    - Use a file pointer to read from/write to any location in a file.
    - Basically it treats the file as a giant array as bytes. Very low-level way to deal with the file.
    - Has a pointer that looks at a place in the file.
    - Methods for moving the pointer (`seek`) and for modifying the file's data starting at the pointer (`readByte`, `readInt`, `readFloat`, etc.).
    - Most powerful I/O class...but is rarely used.

## Streaming interfaces in Java

Any time you open a file and process it, you must make a decision: Is the file's data text or binary? 

In Java: we use readers/writers for text, and we use input/output streams for binary.

## Compress/Decompress

Rodham also said smth about there being Compress and Decompress classes.