


# Computer Security

## Goals

- Data Confidentiality
    - Only authorized people & systems can access data.
- Authentication
    - Verifying a person or system's identity.
- Data Integrity
      - Verifying that data has not been modified.
- Non-repudiation
    - Verifyiing the origin or authorship of data.
    - e.g. deciding if data can be trusted.

## Foundational Concepts

- Cryptographic has functions
- Data Encryption
    - Symmetric key vs. assymetric key encryption
- Secure key exchange
- Public key ???
- Data signatures.

## Cryptographic Hash Functions

Hash functions take an input and output a "digest" (an identifier for the data).

Elements of hash functions

- One-way
    - Given the digest, you cannot recover the input.
    - (This makes the hash function secure.)
- Deterministic
    - Given the same input, you receive the same digest.
- Fixed-size
    - The digest is always the same size, regardless of the input size.
    - Typically the size is pretty small.
- Pseudo-random
    - The digest looks random (even though it's not (bc true randomness is impossible)).
    - i.e. a small change to input makes the digest completely different.

### Algorithms

- Older
    - MD5, designed by Ron Rivest at MIT.
    - SHA-1, designed by National Security Agency.
    - Both have been cracked and should no longer be used for applications that require collision resistance (where it must be infeasible to create two inputs that produce the same digest).
    - Still sometimes used for applications that don't necessitate security as much.
        - e.g. SHA-1 digests are used in Git for commit IDs. 
- MOdern
    - SHA-2 family of algorithms, by NSA.
        - SHA-256 is the most popular. (256 bit digest)
    - SHA-3 is another family of secure hashing algorithms. But it's not in common use yet, bc the SHA-2 algorithms haven't been cracked yet, so they're still secure.

### When hashing is used

- Any time you need a compact, unique summary or identifire for data.
- Any time you want to ensure that data has not been changed.
- Bitcoin mining algorithm uses SHA-256.
    - When you're mining for bitcoin, you're looking for a digest that looks like a particular form.
- Secure user password storage and verification.
- Digital signatures.


## Secure passwords & stuff

### Hashing alone isn't good enough for passwords

- Users that have the same password hashing would have the same password hash values in the db.
    - So while you don't know their password, you know they have the same one. Find one, and 
- Attackers could still crack passwords using a dictionary attack.
    - Pre-compute a dictionary containing the hashes of all likely passwords, then try looking up hashes in your database in the dictionary.

### Salted password hashing

For each user, you generate a random "salt" value, which is appended to their password before hashing it. So tied to each user is `hash(password + salt)`.

This way, users with teh same password no longer have the same password hash value (bc they have different salts). And attackers can no longer use pre-computer password hash dictionaries.

### Speed of password hashing algorithms

Usually, you want a quick hash algorithm. However, for password hashing, you actually want to use a slower hash algorithm that is costly to compute. This way, brute-force attacks take longer.

### Algorithms

- Argon2
- scrypt
- bcrypt (we used in Phase 4)

## Data Encryption

Big part of data security. 

Data encryption lets us securely hide our data from other people. (Except the NSA heheheh.)

### Encryption & Decryption (in Cryptography)

- Encryption is the process of encoding data.
- Decryption is the process of decoding data back to its original form.

<br>

Some terminology:

- Unencrypted data is called **plaintext**.
- Encrypted data is called **ciphertext**.
- Encyrption algorithms oft have a **key**: a piece of information (i.e. a sequence of bits) used as input to a cryptographic algorithm to encode/decode data.
    - **Key size**: # of bits in the key.
        - The bigger the key size, the more difficult it will be to crack the encryption.

### Symmetric (i.e. Secret) Key Encryption

For symmetric key algorithms, the same key is used for both encryption and decryption. 

The hard part for symmetric key algorithms is finding a way to share the symmetric key w/o a hacker capturing it. 

#### Popular algorithms

- Historical
    - Data encryption standard (DES). (56-bit key.)
    - Triple DES (3DES). (Three 56-bit keys.)
- Modern
    - Advanced Encryption Standard (AES).
        - 128-bit, 192-bit, or 256-bit key, and a 128-bit "initialization vector".
        - We'll use AES for our chess project.
    - Blowfish
    - Twofish

### AES

We use the AES algorithm in our Chess Project.


```java

public class SymmetricKeyEncryptionDemo {

    ...

    private static void runAes(int cipherMode, ....) {

        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(cipherMode, key, initVector);

        byte[] inputBytes = new byte[64];
        byte[] outputBytes = null;

        int bytesRead;
        while ((bytesRead = inputStream.read(inputBytes)) != -1) {
            outputBytes = cipher.update(inputBytes, 0, bytesRead);
            if (outputBytes != null) {
                outputStream.write(outputBytes);
            }
        }

        outputBytes = cipher.doFinal(); // gives the algorithm a chance to do any of its last tasks.
        if (outputBytes != null) {
            // ?? ?  ??? 
            ...
        }

        outputStream.flush();
    }
}

```