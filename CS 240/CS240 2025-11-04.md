2025 11 04  
CS 240  
Ken Rodham  
Phase 5 stuff

(We didn't have class last Thursday. We're going to talk ab some of what would have been that day's topics today.)

# Defensive Programming

Compare to defensive driving: Driving as if everyone else doesn't know wtf they're doing and will inevitably make mistakes. Defensive programming is similar, but it's about protecting yourself from yourself.

## `assert`

In JUnit they have all these assert methods on the Assertions class that you can call in your test cases. This is different from that.

Like most languages, Java has an assert keyword to throw an error if something isn't true. You should put assertions across your code to make sure your assumptions about how your code is working is accurate. (e.g., if you assume a variable is not null, add an assertion that checks for that.)

If an assertion fails, the program crashes. This is what you want: If your assertions are failing, it indicates there's a bug in your code. Thus, including assertions makes bug fixing easier (because you catch your mistakes easier).

### Syntax

```java
assert boolean : String; 
```

`boolean` is the boolean expression that's being asserted. `String` is the (String) message that is outputted to the terminal if the assertion fails. (This message is optional tho.)

### Where to use assertions

- Validating parameters are correct.
- Any time you make an assumption in your code. 
    - "I think this is true...but I don't know if it's *always* true..." &mdash; if you're wrong, you'll know.

### Enabling Assertions

- In Java, assertions are **DISABLED by default**.
    - To enable them, run the program with the `-enableassertions` (or `-ea`) option.
        - e.g. `java -ea MyApp`
    - In Intellij, the `-enableassertions` option can be specified in the **VM options** section of the **Run/Debug Configurations** dialog.
       - (Ken's pretty sure that they're disabled by default in Intellij.)
- Assertions are usually disabled in released software. 

### Assertions vs. Exceptions

A failed assertion implies you have a bug.

If one of my assumptions is wrong, shouldn't I throw an Exception? No. You should fix the bug, not throw an exception. (Ken Rodham said you might throw an exception for validating parameters though.)


## Parameter Checking

- Parameter checking = making sure a method/function's inputs are valid.
- If inputs are invalid, your program should indicate an error has occurred rather than proceeding.
- Prevents errors from propagating through the code; detects the bug where it occured.

### How to validate parameter values

There are two main ways:

1. Using asserts.
2. Using if statements and throwing exception.

When to use which? Use assertions for internal functions within a program. If it's a public function that other people besides yourself are going to see & use, use if statements & exceptions (to provide more description).

<!-- Use an assert if you *never* expect or want the input to be invalid. Use an if statement if you have a planned way to handle the error. -->

# How to run multiple instances of a server in Intellij

You need to run multiple clients at once. But by default, Intellij only lets you have one instance of a program running a time. So you have to enable **multiple instances** on the Client program:

Run/Debug Configurations (idk how to get to this) > Client > Add Run Options > Allow multiple instances (Alt+U).

# Phase 5

Three modes the user interface can be in:

1. Pre-login
2. Post-login
3. Gameplay

For Phase 5, you'll implement everything in the pre-login UI and post-login UI. 

Most of the Gameplay UI will come in Phase 6. However, for phase 5, you do need to implement *drawing* the board. Ken says it'd also be really nice if you could implement leaving the game, to make testing easier for the TAs.

Phase 5 is different than previous phases. Previously phases had very specific requirements for you to meet. But Phase 5 is pretty open-ended for what you want your UI to look like and stuff.

## Code structure

You get to decide your code structure for the client; there's no precise requirement for that. However, they provide some suggestions and insights.

### REPL

Each UI is a **read-eval-print loop**, i.e. **REPL**.

- Read: Read user's input.
- Eval: Figuring out which command the user's input correlates to, and executing that command.
- Print: Outputting the command.

Rodham suggests each UI mode be a different class with its own REP loop (probably called `run`).

#### Petshop

You can find Petshop's REPL (there's only one) in client > src > main > client > PetClient.java.

Rodham went over the decomposition in Petshop's REPL: Each R/E/P is its own function, and different 

## Reading input from keyboard

Here's how Petshop's PetClient.java code does it:

```java
Scanner scanner = new Scanner(System.in);
```

`System.in` is **standard input**. We can use a Scanner object to scan tokens from the standard input.


## How do draw pretty things on the console

You can think of the terminal as a 2D grid of cells, and inside each cell is a char. Each char can have a color, a background color, can be italicized or bolded, etc.

When printing to the terminal, there's this concept of the **cursor**. When you print a character, it will be printed to the "cell" that the cursor is on.

### Terminal Control Codes

(i.e. escape sequences)

Typically, when you print to the terminal, the text is just printed out where the cursor is. However, there are funky characters you can send to the terminal that give commands for moving the cursor, changing color, etc. These characters don't display on the screen; they're interpreted as commands.

What control codes do what is typically defined by a standard (e.g. ANSI escape sequences standard). However, for phase 5, you've been provided a file with a buuuunch of constants for control codes that you can "print" to the terminal. (Look for **EscapeSequences.java**)

e.g., to erase the screen, you'd use `System.out.print(ERASE_SCREEN)`

#### Printing new lines

When you print a new line, it actually just fills out the rest of the line (I assume w/ spaces). So whatever properties you have activated, it will fill the rest of the line with taht. 

### Unicode characters

- Many (most) terminals can display (at least a subset of) Unicode characters.
- In Java, Unicode character constants begin w/ the `\u` prefix.
    - e.g. `\u2654` - White king
    - e.g. `\u265f` - Black pawn.
- You may consider using unicode characters for chess pieces instead of text characters.
    - On the other hand, alpha characters are guaranteed to be equal width, so lining things up is really easy.
        - (If you do go the unicode route, there are unicode characters for wider spaces that you'd want to use to get everything aligned.) 
            - `\u2003` is the wider space.

#### Escape Sequences

The EscapeSequences class has constants for the different chess pieces. This is where you would decide whether you want alphanumerical characters or the unicode characters.

### Configuring Intellij's terminal

For most, the terminal will just work. But your terminal may take some configuration.

> Make sure your terminal is using a monospace font! File > Settings > Editor > Color Scheme > Console Font

### Client HTTP stuff

Java has class called `HttpClient` you can use to instantiate a client:

```java
private final HttpClient httpClient = HttpClient.newHttpClient(); 
```

To send requests, Java has an `HttpRequest` that can build requests:

```java
HttpRequest request = HttpRequest.newBuild()
    .uri(new URI(urlString))
    .timeout(java.time.Duration.ofMillis(TIMEOUT_MILLIS)) // setting how long the request runs before quitting
    .header("authorization", "abc123")
    .GET() // specifies that this is a get request
    .build(); // (always put this last)
```

And then for responses, use an `HttpResponse<String>` class.

<!-- ```java
HttpResponse<String> httpResponse = client.send(request, HttpResponse.BodyHandlers().toString()); // no idea wtf this is.

if (httpResponse.statusCode() == 200) {
    HtppHeaders headers = httpResponse.headers();
}
``` -->

> There's some example code (somewhere, idk where) for the client's get and the post requests. (How to instantiate the client, how to send requests from the client, how to handle responses, etc.)

## Server Facades

A server facade is a class that implements all the same methods the Server does, but doesn't run a server, which I suppose can make testing easier or smth idrk.

Idk why we're talking ab it, bc frankly it seems like you can just use the Server class? Idrk.

One way or another though, you have to write a server facade class *and* unit tests for it for Phase 5. (Why?????)

## Pass Off

For Phase 5, **you will do your pass offs manually, with a TA**.

## Commits

For Phase 5, you need at **least 12 commits.**