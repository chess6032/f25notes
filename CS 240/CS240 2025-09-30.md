2025 09 30  
CS 240  
Ken Rodham  
JSON & Principles of Good Software Design

We're done talking about Java directly. Now, we're going to be focusing on the skills and habits necessary for building larger programs.

In Thurs in class, we're going to do a deep-dive into the design for the chess server. (Obv it's more broad than just the chess server.) Rodham said this was the most important lecture to attend.



# Principles of good software design

As a program gets larger, its code becomes harder to deal with. So we have to be more careful, more thoughtful, more deliberate in how we do stuff.

Later on, on another day, we'll talk about good coding practice. Today it will be higher level.

## Students said

Ken started by asking us, the students, some principles we abide by.

### DRY

"DON'T REPEAT YOURSELF." Copy/paste programming is bad. 

### Good naming

"There are only two hard things in Computer Science: cache invalidation and naming things." - Phil Karlton.

## Goals of software design

The goal of software design is to create systems that:

- Works.
- Satisfies customer requirements.
- Easy as possible to understand, debug, and maintain.
- Hold up well under changes & new features.

## Principle #1: Design is inherently iterative

Which comes first? Design, or implementation? Design, of course. But what happens if you spend too much time designing? You might find while coding that your design doesn't actually work too well.

Design &rarr; implement &rarr; test &rarr; design &rarr; implement &rarr; test &rarr; design &rarr; implement &rarr; test &rarr; design &rarr; implement &rarr; test...

- Beginning implementation w/o any design doesn't work.
- Designing everything before beginning implementation also doesn't work.

## Principle #2: Abstraction

- Abstraction is one of the software designer's primary tools for coping with COMPLEXITY.
- After you create something, you treat it like a black box.
- In OOP, abstractions are represented by classes.
- Low-level abstractions: Many programming languages have abstractions of the machine. 
    - e.g. string classes, I/O stream classes, etc.
    - Programs written solely in terms of these low-level classes are very difficult to understand.
- High-level abstractions: Software designers must create higher-level, domain-specific classes, and write their software in terms of those.
    - We're trying to raise the abstraction level of what our language provides.
- **High-level classes are implemented in terms of lower-level classes.**

Some classes correspond to "real world" concepts in the application domain. (e.g. bank, customer, person, event, marriage...). Other classes do not correspond to "real world" domain concpets, but are needed for internal implementation. (e.g. HttpServer, Database, HashTable...)

### Benefits of abstraction

- Allows you to not have to worry about how everything works under the hood.
    - You can't hold all the details in your head at the same time.
- You can change how everything works under the hood without changing anything above the hood. (lol does that make any sense.)

### Compromising during abstraction

Classes often model complex, real-world objects. You generally can't fully represent the thing you are abstracting, so you have to make domain appropriate decisions about what to represent in methods and variables. You have to decide what aspects of the realworld thing are relevant to include, and which details you should exclude.

e.g. Do you care about a heart-rate or fingerprint attribute in a Person class? (Probably not...unless you're working for the FBI or a heart surgeon)

## Principle #3: Good naming

Sftwr designers name tons of stuff (variables, functions, classes, folders, projects, etc.), so it's important you have a good sense of how to name things well. (Plus, your kids will appreciate it if you're good at naming things.)

Just think about it hard. Rodham says sometimes he even breaks out a thesaurus.

- Names should clearly convey their function and purpose.
- Class and variable names are typically nouns.
- Function/method names are usually verbs.
    - Sometimes though, you'll name a function after a noun if the most important thing about it is what it returns. e.g. `PenColor currentPenColor()`, or `int size()`.

## Principle #4: Single-Responsibility Principle (i.e. cohesion)

DEF: Each class and function should only do one thing. Everything should exist for primarily one reason.

- Each class & method should have a single responsibility.
- Each class should represent one well-defined concept.
    - All vars & methods in a class should be highly related to the class's single responsibility cohesion.
- Each method should perform one well-defined task.
    - Unrelated or loosely related tasks should be in different methods.
- What if a method *has* to do perform multiple tasks? Each task should be delegated to its own sub-method.
- Cohesive classes and methods are easier to name.

## Principle #5: Decomposition

Decomposition is related to abstraction. When you do abstraction, you're breaking the program into pieces. Decomposition is about how you relate those pieces together...or something???? IDRK.

### Levels of decomposition

1. System.
2. Subsystems.
3. Packages.
4. Classes.
5. Methods.

## Principle #6: Good algorithm & data structure selection

For algorithms: What is the Big O? How well does the algorithm work with the data sets you're working with?

- No amount of decomp or abstraction will hide a fundamentally flawed selection of data structure or algorithm.

## Principle #7: Low coupling

Coupling = connections between two things. 

Any time two classes interact, they're coupled. **You want each class to be as independent as possible**: You want it to interact with & be aware of other classes as little as possible.

Sometimes people say you should write shy code.

No coupling is impossible, obviously. Coupling is inherently necessary. So you just have to be wise.

### Benefits

Low coupling minimizes ripple. The more coupling between classes, the more a change in one class will ripple across your project. 

You want to be able to change one thing without having to change everything else.

Low coupling makes debugging easier: Everything is more isolated. It's harder to identify which specific part of the program is breaking when they're all interconnected and depended with each other.

## Principle #8: Encapsulation

Encapsulation = information hiding.

- Every class should hide its underlying implementation.
- Minimize visibility.
- "public", "protected", "private".
- A class's public interface should be as simple & minimal as possible.
- Encapsulation is essential to low coupling btwn classes.

Anything in software engineering that depends on discipline is dicey. It's better to use tools that enforce good behavior.

Any time you release a class to the wild, it's no longer yours.

### Encapsulation and naming

- Don't let internal details "leak out" of a class.
    - e.g. instead of `StudentLinkedList`, name it `ClassRoll`.
    - You don't want to broadcast the implementation.
        - People don't care about how your class is implemented, they care about how they can use it.
- It's OK to reveal internal details if the underlying implementation is important to its usage.

## Principle #9: Separation of interface & implementation

- **Program to interfaces instead of to concrete classes.**
- Maintain a strict separation btwn a class's interface and its implementation.
    - It's better if a member variable has an interface type than a concrete class type.
- This allows internal details to change without affecting clients.

## Principle #8: Avoid code duplication

- DRY: Don't repeat yourself.
- Disadvantages of code dupe:
    - You have to maintain each copy.
    - Bugs appear in each copy.
- Solutions:
    - Factor common code int oa separate method or class.
    - Shared code might be placed in a common superclass.

# JSON

[GitHub link.](https://github.com/softwareconstruction240/softwareconstruction/blob/main/instruction/json/json.md)

JSON is a data format that is very prominent in building data systems these days. (It's also important for this project.)

JSON stands for "JavaScript Object Notation". It is (one possible) data representation syntax that is powerful yet simple. It makes data easily sharable.

## Format

- Supported data types
    - Strings (`""`)
    - Numbers
        - Does not distinguish floats from ints.
        - All numbers are stored as an 8-byte double. (Same way JS does.)
    - Boolean (`true`/`false`).
    - Arrays (`[]`)
    - Object (`{"property":value}`)
        - Property/value pairs separated by commas.
        - Properties are always strings.
        - Values can be anything.
    - Null (`null`)
        - Indicates lack of a value, or a missing value.

## Examples

### Verbose

```json
{
    "CATALOG": [
        { "CD": {
            "TITLE": "Hide your heart",
            "ARTIST": "Bonnie Tyler",
            "COUNTRY": "UK",
            "YEAR": 1988
            }
        },
        { "CD": {
            "TITLE": "Greatest Hits",
            "ARTIST": "Dolly Parton",
            "COUNTRY": "USA",
            "YEAR": 1982
            }
        }
    ]
}
```

As you can see, at the end of the day, JSON is a tree.

### Less verbose

```json
[
    {
        "TITLE": "Hide your heart",
        "ARTIST": "Bonnie Tyler",
        "COUNTRY": "UK",
        "YEAR": 1988
    },
    {
        "TITLE": "Greatest Hits",
        "ARTIST": "Dolly Parton",
        "COUNTRY": "USA",
        "YEAR": 1982
    }
]
```

## Processing JSON

To use JSON files, you must be capable of **generating** and to **parsing** JSON files. Luckily, most languages provide JSON parsers, so there's no need to write your own.

In this project, we'll use Google's JSON library: GSON.

- Three major types of parsers:
    - Stream parsers
        - Tokenizers that return one token at a time from the JSON data file.
        - The tokens of a JSON file would be the data types JSON supports (Strings, objects, numbers, arrays, and nulls).
        - Lower level, harder to use. But useful if you don't care about reading an entire JSON file. (e.g., it's a really big JSON file and you only want a specific piece of data.)
        - The other two parser types listed here are higher level parsers built on top of stream parseres.  
    - DOM parsers
        - Convert JSON text to an in-memory tree data structure. (The tree is called a DOM, or "document object model.")
        - After running the parser to create a DOM, traverse the DOM to extract the data you want.
        - Disadvantage: If you have a big JSON file, the DOM will take up a lot of memory.
    - Serializers/deserializers
        - Use a library to convert from JSON to Java Objects (and vise versa).
        - Serialization: Java Object &rarr; JSON.
            - Why would it be helpful to convert a Java Object to JSON? You need to be capable of taking your objects from RAM and converting them to a format that can be stored and saved and shared to elsewhere.
        - Deserialization: JSON &rarr; Java Object.
        - Gson and Jackson are both popular libraries for this.
        - This is the type of parser you'll most likely use in your project.


### Examples

There were some lecture code examples...or something idk.