2025 09 16  
ENGL 202  
Ken Rodham  


# Classes

## Object Method Overrides

(Recall: Classes inherit from Java's built-in Object class (if no superclass is given).)

### equals

`==` compares two objects' **memory address**. This only returns true if you're comparing an instance of an object with itself. Hence, Rodham called this the **identity equality**.

`Object.equals` compares two objects' **values**. Hence, Rodham called this **value equality**. 

However, the Object class's `equals` method implements identity equality. For your class's `equals` method to compare via value equality, **you have to override the `equals` method and implement value equality yourself**.

### hashCode

(See Hash Tables below.)

Requirements for a hashing function:

- Must be fast.
- When run repeatedly, must always return the same value.
- Two equal objects must return the same hash code.
- Two different objects must return different hash codes.

<br>

`Object.hashCode` is implemented w/ **identity equality**. i.e. The hash code is derrived by the object's **memory address**.

To override `hashCode` so that it implements **value equality**, you can just call a Java's `Objects.hash` function with all the class's fields as inputs, like this:

```java
public class ChessPiece {

    private final TeamColor team;
    private final PieceType type;

    ...

    @Override
    public int hashCode() {
        return Objects.hash(team, type);
    }
}
```

(This is what Intellij makes when you use it to generate a `hashCode` override.)

# Hash Tables (review)

Behind the scenes, hash tables drive much of what you do when you program. (e.g. dictionaries and maps are almost always implemented via hash tables.)

Hash tables are cool because they run in "Amortized constant time". This means that, on average, it runs at $O(1)$. ("Amortized" means "almost always"...there are still times when a hash table will be slow.)

The tradeoff is that hash tables cost more memory. (Time vs. memory is a common tradeoff in CS.)

## Implementation

A hash table is just an array of values. 

- Let's use a hash table to make a set. We'll wrap the array in a class that provides the following operations:
    - insert
        - When storing an object, our hashset asks the object for its hash code. The object gives it, and our hashset uses that hash code (after modulating it by the size of the array) and places the object at that index in the array.
            - Hash code &mdash; object's placement in array. 
    - find
        - Get the object's hash, and look at that index in the array.
    - remove
        - Get the object's hash, and look at that index in the array. If it's there, remove it.

# Programming exam

The programming exam is really an entrance exam for the class.

**Within a four hour period, with no access to your prior code, Google, nor AI, can you recreate Phase 0?**

If you pass all the test cases, you pass the exam. (All or nothing.)

What you do have access to:

- Java documentation.
- Textbook. (Which no one ever uses lol.)
- Project specifications.

You'll make a new chess repo and clone it to your machine *BEFORE* you start taking the test.

Exam taken in Canvas and proctored with **Honorlock**. Prior to taking the exam, you have to take the *Honorlock Setup/Acknowledgement Quiz (Proctored)* in Canvas to make sure Honorlock works on your machine. You need to **install the Honorlock extension** and **uninstall the Proctorio extension** if you have it.

For Honorlock, you need a **webcam and microphone**, as well as an internet connection. You can take it anywhere that meets those requirements.

Practice is key. In Canvas, there's a practice programming exam. It's not proctored; it's just for practice. This is the best way to be prepared. Rodham recommends doing it three times, even.

**Make sure to leave a few minutes at the end to turn your files in.**

You *can* go to the bathroom during the exam. Honorlock may flag that, but they'll figure it out. (Don't go to the bathroom to cheat, obv.)

If your technology fails on you, just keep going, and talk to Rodham after the fact. (He says he'll probs just accept your score.) He doesn't want you to have to stop and redo the exam if Honorlock trolls you.

# Inheritance in Java

Reasons for inheritancy:

- Code reuse.
- **Polymorphism**.
    - Referring to superclass/interface in your code so that it always works regardless of what subclass the object is.

## In Chess

For the chess project, it's recommended you create a moves calculator superclass, and then make subclasses of that for each piece.

The `ChessGame` class also has a method for calculating moves. This is where you check that a move is **legal** (e.g. seeing if a move puts your king in checks/checkmate).


## Multiple inheritance

**In Java, you can only inherit from one class.**

However, Gemini tells me a class can inherit from multiple *interfaces*, so you can achieve multi-inhertance that way. 

## Subclass overrides

### Constructors

First step is to call the super's constructor: Call `super()` (with the inputs the super's constructor requires).

Then, instantiate any of the subclass's fields.

### `toString`

Frequently, you'll use the superclass's string and then append info related to the subclass.

### `equals`

Frequently, you'll include `if (!super.equals(o)) return false;`, so that you don't have to duplicate logic written in your superclass. This way, you avoid having to write new logic to check whether the values of the fields the sublcass inherited are equal.


## Public, Private, & Protected

- Public: Visible to all classes.
- Private: Visible only to that class.
- Protected: Visible to that class and any classes that inherit from it.
    - i.e. visible to any class inside the inheritance relationship.

For a subclass to be capable of overriding a superclass's method, the method *must* be either public or protected. **Subclasses can't override private methods** (because they can't even see them).

## `abstract`

An abstract class or method is not fully defined. Abstract classes cannot be instantiated.

An abstract method is useful when you have a method that you want to be defined by subclass's, not the superclass.

Only abstract classes can have abstract methods.

## `final` methods

If you include the `final` keyword in a method signature, subclass's can't override it.