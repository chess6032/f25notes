2025 10 14  
CS 240  
Ken Rodham  

# Testing Pyramid


```
More integration                     Slower 

                  END-TO-END TESTS

                INTEGRATION TESTING

                    UNIT TESTS

Less integration                      Faster

```

In Phase 0 and 1, you had some unit tests given to you. But in Phase 3 and on, the tests given to you will not be unit tests.

# Unit Testing

Unit Testing is smaller-scale testing. It's taking out the gears in the machine and making sure each one works.

"Unit" == small piece. Can be a function, method, class, etc.


## How they work

- Create objects, call methods, and verify that the returned results are correct.
- Automation is the goal.
    - You don't want to do testing manually.
    - You want to write programs to test your programs.
        - Often called a "test driver".
    - "Regression testing."
    - You run a program that runs multiple tests and it outputs which ones passed and which didn't.
- Notifies you when the changes have introduced bugs, and helps to avoid destabilizing system.

Each test works like this: Create an instance of the class you're testing (or the class containing the method you're testing), and compare some given expected results to the actual results. If the results are equal, the test passed. If not, they failed.


## Test driver

- Test driver = program that runs unit tests.
- Little or no manual labor should be required.
- It should be easy to add new tests.

## Essentials of unit tests

- **Fast:** Unit tests must run quickly so they can be run often.
- **Cohesive:** Each unit test case should test one specific thing
    - (And it should a good name that describes what it tests.)
    - Don't test a bunch of different things in one test case. Each test case should test one thing at a time. And that way, when a test fails, you'll know specifically what failed.
- **Independent:** Unit test cases should not have side effects that impact the execution of other tests. It should be possible to run unit test cases in any order w/o affecting their success.
    - Each test case should start with a "clean state". Whatever data the test case uses should start at a clean, initial state.
- **Unique:** Each unit test should test something different and not just repeat what other test cases do.


## JUnit Testing Framework

JUnit 5 introduced Jupiter. You want to use Jupiter. So if you're ever asked whether you want to use JUnit 5 or an earlier version, pick version 5. 

Test statuses:

- Green: Test passed.
- Yellow: Test failed.
- Red: Code didn't run. (e.g. Exception or compiler error.)

The JUnit library has an `Assertions` class with a bunch of different assert methods (each method starts w/ `assert`). For each of these methods, the **first** value is the **expected** value, and the **second** value is the **actual** value.

### Annotations

Every method that is a test case is annotated with `@Test` right above it. 

You can also add a `@DisplayName("Test name")` annotation above the method. JUnit will use this name when it outputs the test's status. (If there is no `@DisplayName` annotation, it uses the method name.)

Another annotation is the `@BeforeEach`. A method labelled `@BeforeEach` runs before each test case method runs. If you're setting up each test case in the same way, you can move that logic to a new function and label it `@BeforeEach`

Similarly, `@AfterEach` runs after each test case method. 

Similarly but different, `@BeforeAll` runs *once* before all the tests are ran, and `@AfterAll` runs once after all the tets are ran.

`@TimeOut(5)` will fail the test if it doesn't finish in 5 seconds.

## Code Coverage

Code coverage refers to how much of your code your unit tests covers. IDEs often have tools for checking it.

Running tests w/ code coverage in Intellij looks at all the code in a package and displays a table of what percentage of classes, methods, lines, and branches your test cases cover.

Running w/ test coverage will also color files in the file explorer on the left of Intellij. Green == file/package was completely tested, yellow == partially tested, red == untested.

It also displays green/yellow/red tabs on the left of tested lines. Hover your mouse over these tabs to reveal more information. ("Hits" tells you how often the line of code was ran.) You can use this to, say, make sure that your tests are testing both the true case & the false case of an if statement. 

Code coverage tools also exist outside of an IDE, oft runnable from the command line. For Java, there's dozens of tools like this. A good one, Rodham said, is Jacoco.

## Don't be deceived

Unit tests are necessary but not sufficient.

Having good unit tests that cover all your code and each one passing does not mean that your software works. You still nead to cover integration testing, system testing, end-to-end testing, etc.

# Phase 3

In Phase 3, you need to make Service Unit Tests.

In your server, you're going to have roughly 3 service classes, and roughly 7 methods across them. 

Phase 3 requires you to write two test cases for each public method in each Service class: One test case for it a method succeeds (positive test case), and one test case for if a method fails (negative test case).

Your tests will call the Service class's methods directly. You don't want to be calling the methods through the server. (If HTTP is involved with your test cases, you're not doing it right.)